import java.awt.Color;
import java.util.ArrayList;


public class World {
	
	
	private final int  DIMENSION = 900;//if this is changed, everything breaks. Fix that the +90 is b/c stdDraw adds a 10% boarder for some reason
	public final int ARRAY_DIM = 15;
	private Entity[][] objectLocations = new Entity[ARRAY_DIM][ARRAY_DIM];//this 2D array will have all of the locations of all of the current objects in the world i think that the 2d array should also have different numbers to indicate what kind of object is in a certain loaction
	/*
	 * for object locations: 
	 * 0 = empty place
	 * 1 = unbreakable block
	 * 2 = breakable block
	 * 3 = character
	 * 4 = bomb
	 * 5 = bomb explosion 
	 * 6 = block
	 */
	
	
	
	/**
	 * Creates world, generates blocks
	 */
	public World(){
		StdDraw.setCanvasSize(DIMENSION,DIMENSION); 
		StdDraw.setXscale(0, DIMENSION);
		StdDraw.setYscale(0, DIMENSION);
		generateBreakableBlocks();
		generateUnbreakableBlocks();
	}
	
	/**
	 * generates breakable blocks 
	 */
	private void generateBreakableBlocks(){
		for(int row=0;row<objectLocations.length;row++){
			for(int col=0;col<objectLocations[row].length;col++){
				if(col%2!=0 && row%2 != 0){
					objectLocations[row][col]= (new BreakableBlock(col,row)) ;
				}
			}
		}
	}
	
	
	/**
	 * generates unbreakable blocks 
	 */
	private void generateUnbreakableBlocks(){
		for(int row=0;row<objectLocations.length;row++){
			for(int col=0;col<objectLocations[row].length;col++){
				if(col%2==0 && row%2 ==0 ){
					objectLocations[row][col] = new UnbreakableBlock(col,row); //every other space in every other row will have an unbreakable block

				}
			}
		}
		//leaves empty spots for the player
		objectLocations[0][0] = null;
		objectLocations[ARRAY_DIM-1][0]=null;
		objectLocations[0][ARRAY_DIM-1]=null;
		//objectLocations[ARRAY_DIM-1][ARRAY_DIM-1] =null;
		

		
	}
	
	
	


	/**
	 * checks if valid
	 * @param x
	 * @param y
	 * @return
	 */
	public boolean isValid(double x, double y){
		//bounds of grid
		if(x>900 || x<0 || y>900 || y<0){
			return false;
		}
		//checks for other objects
		if(objectLocations[14-((int)(((y-30)*15)/900))][(int)(((x-30)*15)/900)] !=null && objectLocations[14-((int)(((y-30)*15)/900))][(int)(((x-30)*15)/900)].getID()==1){//converts x/y-coordinates back into row/col
			if(objectLocations[14-((int)(((y-30)*15)/900))][(int)(((x-30)*15)/900)].getID()==1){
				return false;
			}
			if(objectLocations[14-((int)(((y-30)*15)/900))][(int)(((x-30)*15)/900)].getID()==2){
				return false;
			}	
		}	
		return true;
	}

	
	/**
	 * displays world
	 */
	public void display(){
		//sets background to green
		StdDraw.clear(Color.green);
		//goes through and draws each object
		for(Entity[] a : objectLocations){
			for(Entity b : a){
				if(b !=null)
					b.draw();
			}
		}
	}
	
	//returns what number is in objectLocations at the specified row and col
	public int getOccupants(int row,int col){
		return objectLocations[row][col].getID();
	}
	
	//adds a bomb
	public void addBomb(int col, int row){
		objectLocations[row][col] = (new Bomb(1,col,row))  ;
	}
	
	//removes an object 
	public void removeOccupant(int row,int col){
		objectLocations[row][col]=null;
	}
	
}

